{"version":3,"file":"index.mjs","sources":["../src/index.js"],"sourcesContent":["'use strict'\n\nfunction NOOP () {}\n\nconst METHODS = 'map,scan,dedupe,dedupeWith,when'.split(',')\n\nclass Stream {\n  static create (...args) {\n    return new Stream(...args)\n  }\n\n  constructor (v) {\n    // current value of the stream\n    this.value = v\n    // notify callbacks to run on change\n    this.notify = new Set()\n    // fn which detaches this stream from its parents\n    this.detacher = NOOP\n\n    // function version of the stream. Call with no args\n    // to get current value. Or with args to set.\n    this.fn = this.update.bind(this)\n    // to map back from the function to the object\n    this.fn.stream = this\n\n    // make function versions of the methods\n    METHODS.forEach(meth => {\n      this.fn[meth] = (...args) => this[meth](...args).fn\n    })\n  }\n\n  subscribe (fn) {\n    this.notify.add(fn)\n    return () => this.notify.delete(fn)\n  }\n\n  endStream () {\n    this.notify.clear()\n    this.detacher()\n    this.detacher = NOOP\n  }\n\n  addEnd () {\n    // and end stream is a stream which, if updated, ends the stream\n    // (along with itself)\n    this.end = Stream.create()\n    this.end.subscribe(() => {\n      this.end.endStream()\n      this.endStream()\n    })\n    // the fn version of the stream also has an end, which is the fn version\n    // of `stream.end`\n    this.fn.end = this.end.fn\n  }\n\n  update (v) {\n    if (arguments.length !== 0) {\n      this.value = v\n      // work off a copy as some notifieds might change this\n      // as we are iterating (e.g. ends)\n      const notifies = Array.from(this.notify)\n      notifies.forEach(f => f(v))\n    }\n    return this.value\n  }\n\n  // creates a new Stream which is derived from applying a function\n  // to a list of (upstream) Streams\n  //\n  // The function has signature\n  // (stream,...,stream, self, Stream[] changed) => value\n  // where `changed` is the list of Stream objects that have changed.\n  //\n  static combine (fn, streams) {\n    const derived = Stream.create()\n    // any time any of the parent streams change, we re-run the\n    // function.\n    //\n    // The unsubscribes are stored and used as as the detacher for this\n    derived.detacher = callAll(\n      streams.map(stream =>\n        stream.subscribe(() => {\n          const ret = fn(...[...streams, derived, [stream]])\n          if (ret != null) derived.update(ret)\n        })\n      )\n    )\n\n    // Any time the `end`s of any of the parents are called, then we\n    // call our own `end`. The unsubs again form the detacher for the `end`\n    derived.addEnd()\n    derived.end.detacher = callAll(\n      streams.map(stream => stream.end.subscribe(x => derived.end.update(x)))\n    )\n    return derived\n  }\n\n  map (fn) {\n    return Stream.combine(s => fn(s.value), [this])\n  }\n\n  dedupeWith (cmp) {\n    let prev\n    return Stream.combine((source, target) => {\n      const val = source.value\n      if (!cmp(prev, val)) target.update(val)\n      prev = val\n    }, [this])\n  }\n\n  dedupe () {\n    return this.dedupeWith(identical)\n  }\n\n  static merge (...streams) {\n    const merged = Stream.combine((...args) => {\n      const changed = args.pop()\n      const self = args.pop()\n      changed.forEach(s => self.update(s.value))\n    }, streams)\n    return merged\n  }\n\n  scan (fn, accum) {\n    const derived = this.map(value => {\n      accum = fn(accum, value)\n      return accum\n    }, [this])\n    derived.value = accum\n    return derived\n  }\n\n  when (fn) {\n    // return a stream of promises which resolve when the condition\n    // is true\n    let resolver\n    let isResolved\n    const freshPromise = () =>\n      new Promise(resolve => {\n        resolver = resolve\n      })\n\n    const initialPromise = freshPromise()\n    if (fn(this.value)) {\n      isResolved = true\n      resolver()\n    }\n\n    return this.scan((prom, value) => {\n      if (fn(value)) {\n        if (!isResolved) {\n          isResolved = true\n          resolver()\n        }\n      } else {\n        if (isResolved) {\n          isResolved = false\n          prom = freshPromise()\n        }\n      }\n      return prom\n    }, initialPromise)\n  }\n}\n\nfunction callAll (cbs) {\n  return () => cbs.forEach(f => f())\n}\n\nfunction stream (...args) {\n  const str = Stream.create(...args)\n  str.addEnd()\n  return str.fn\n}\n\nfunction combine (fn, streamFuncs) {\n  return Stream.combine((...args) => {\n    const changed = args.pop()\n    const self = args.pop()\n    return fn(...[...args.map(s => s.fn), self.fn, changed.map(s => s.fn)])\n  }, streamFuncs.map(sf => sf.stream)).fn\n}\n\nfunction merge (...streamFuncs) {\n  return Stream.merge(...streamFuncs.map(sf => sf.stream)).fn\n}\n\nfunction identical (a, b) {\n  return a === b\n}\n\nObject.assign(stream, { combine, merge })\nexport default stream\n"],"names":["NOOP","const","METHODS","split","Stream","constructor","v","value","notify","Set","detacher","fn","this","update","bind","stream","forEach","meth","ref","args","callAll","cbs","f","str","create","addEnd","identical","a","b","subscribe","add","delete","endStream","clear","end","arguments","length","Array","from","combine","streams","derived","map","ret","x","s","dedupeWith","cmp","prev","source","target","val","dedupe","merge","changed","pop","self","scan","accum","when","resolver","isResolved","freshPromise","Promise","resolve","initialPromise","prom","Object","assign","streamFuncs","sf"],"mappings":"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"}
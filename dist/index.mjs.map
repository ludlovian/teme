{"version":3,"file":"index.mjs","sources":["../src/index.js"],"sourcesContent":["'use strict'\n\nconst sym =\n  typeof Symbol === 'function'\n    ? Symbol\n    : /* istanbul ignore next */ x => '$teme$_' + x\n\nconst kValue = sym('value')\nconst kParents = sym('parents')\nconst kChildren = sym('children')\nconst kFunction = sym('function')\nfunction NOOP () {}\n\n// The main entry point for source streams (as opposed to derived ones)\n//\n// A stream is a function (acting as a get/setter), but inheriting\n// prototypically from Stream\n//\nexport default function Stream (v) {\n  const s = createStream(v)\n  s.end = createStream(false)\n  // special link between stream and its `.end`\n  s.end[kChildren].add(s)\n  return s\n}\n\n// Constructs a stream function, setting its own proerties and prototype\nfunction createStream (value) {\n  function stream () {\n    if (arguments.length !== 0) {\n      setStreamValue(stream, arguments[0])\n    }\n    return stream[kValue]\n  }\n\n  Object.defineProperties(stream, {\n    [kValue]: { value, configurable: true, writable: true },\n    [kChildren]: { value: new Set(), configurable: true, writable: true },\n    [kParents]: { value: [], configurable: true, writable: true },\n    [kFunction]: { value: NOOP, configurable: true, writable: true }\n  })\n  Object.setPrototypeOf(stream, Stream.prototype)\n  return stream\n}\n\nlet updates\n\nfunction setStreamValue (stream, value) {\n  const topUpdate = updates == null\n  if (topUpdate) updates = getDescendants(stream)\n\n  stream[kValue] = value\n  Array.from(stream[kChildren]).forEach(child => {\n    if (child.end === stream) return endStream(child)\n    const update = updates.find(u => u.stream === child)\n    if (!update) return updates.push({ stream: child, changed: [stream] })\n    update.changed.push(stream)\n  })\n\n  if (topUpdate) {\n    for (let update = updates.shift(); update; update = updates.shift()) {\n      if (update.changed.length !== 0) {\n        recalculateStream(update.stream, update.changed)\n      }\n    }\n    updates = undefined\n  }\n}\n\n// getDescendants\n//\n// perofrms a topological search to find all descendants of the given stream,\n// returning them in order than they should be updated - from most senior\n// (parent-like) to most junior (child-like)\nfunction getDescendants (root) {\n  const result = []\n  const seen = new Set()\n  // visit actuall creates the array from junior to senior order, processing\n  // the children before adding the current node. Finally we have to reverse\n  // this array to make it senior-to-junior\n  function visit (stream) {\n    if (seen.has(stream)) return\n    seen.add(stream)\n    stream[kChildren].forEach(visit)\n    result.push({ stream, changed: [] })\n  }\n  visit(root)\n  return result.reverse()\n}\n\nfunction recalculateStream (stream, changed) {\n  const args = [...stream[kParents], stream, changed]\n  const ret = stream[kFunction](...args)\n  if (ret != null) setStreamValue(stream, ret)\n}\n\nfunction endStream (stream) {\n  // disconnect from parents\n  stream[kParents].forEach(parent => parent[kChildren].delete(stream))\n  stream[kParents] = []\n  stream.end[kParents] = []\n\n  // set .end to true\n  stream.end[kValue] = true\n\n  // end all downstream from me too\n  Array.from(stream[kChildren]).forEach(endStream)\n}\n\n// The workhorse for all derived streams\n//\nStream.combine = function combine (fn, streams, opts = {}) {\n  const derived = Stream(opts.initial)\n  derived[kFunction] = fn\n  derived[kParents] = streams.slice()\n  streams.forEach(parent => parent[kChildren].add(derived))\n  if (!opts.skip) recalculateStream(derived, streams)\n  return derived\n}\n\n// common methods for all streams\nStream.prototype = {\n  subscribe (fn) {\n    const derived = this.map(fn, { skip: true })\n    return () => derived.end(true)\n  },\n\n  map (fn, opts) {\n    return Stream.combine(s => fn(s()), [this], opts)\n  },\n\n  clone () {\n    return this.map(x => x)\n  },\n\n  merge (...streams) {\n    return Stream.merge(...[this, ...streams])\n  },\n\n  scan (fn, accum) {\n    return this.map(\n      value => {\n        accum = fn(accum, value)\n        return accum\n      },\n      { skip: true, initial: accum }\n    )\n  },\n\n  dedupe (cmp, opts) {\n    if (cmp && typeof cmp === 'object') {\n      opts = cmp\n      cmp = undefined\n    }\n    cmp = cmp || identical\n    opts = opts || {}\n    let prev\n    if (!opts.skip) prev = this()\n    return Stream.combine(\n      (source, target) => {\n        const val = source()\n        if (!cmp(prev, val)) target(val)\n        prev = val\n      },\n      [this],\n      { skip: true, initial: prev }\n    )\n  },\n\n  when (fn) {\n    let resolver\n    let isResolved\n    const freshPromise = () =>\n      new Promise(resolve => {\n        resolver = resolve\n      })\n    const initialPromise = freshPromise()\n    if (fn(this())) {\n      isResolved = true\n      resolver()\n    }\n\n    return this.scan((prom, value) => {\n      if (fn(value)) {\n        if (!isResolved) {\n          isResolved = true\n          resolver()\n        }\n      } else {\n        if (isResolved) {\n          isResolved = false\n          prom = freshPromise()\n        }\n      }\n      return prom\n    }, initialPromise)\n  },\n\n  changed () {\n    return new Promise(resolve => {\n      const unsub = this.subscribe(x => {\n        resolve(x)\n        unsub()\n      })\n    })\n  },\n\n  throttle (period) {\n    let timeout\n    let callDue\n    const update = () => {\n      derived(this())\n      callDue = false\n    }\n    const startTimer = () =>\n      setTimeout(() => {\n        if (callDue) {\n          update()\n          timeout = startTimer()\n        } else {\n          timeout = null\n        }\n      }, period)\n    const derived = Stream.combine(\n      () => {\n        if (timeout) {\n          callDue = true\n        } else {\n          update() // leading edge\n          timeout = startTimer()\n        }\n      },\n      [this],\n      { skip: true }\n    )\n    return derived\n  },\n\n  debounce (period) {\n    let timeout\n    const update = () => {\n      derived(this())\n      timeout = null\n    }\n    const startTimer = () => {\n      if (timeout) clearTimeout(timeout)\n      timeout = setTimeout(update, period)\n    }\n    const derived = Stream.combine(startTimer, [this], { skip: true })\n    return derived\n  }\n}\n\nStream.merge = function merge (...streams) {\n  return Stream.combine(\n    (...args) => {\n      const changed = args.pop()\n      const self = args.pop()\n      changed.forEach(s => self(s()))\n    },\n    streams,\n    { skip: true }\n  )\n}\n\nStream.fromPromise = function fromPromise (p) {\n  const s = Stream()\n  p.then(\n    result => {\n      s(result)\n      s.end(true)\n    },\n    reason => {\n      if (!(reason instanceof Error)) {\n        const err = new Error('Rejected promise')\n        err.promise = p\n        err.reason = reason\n        reason = err\n      }\n      s(reason)\n      s.end(true)\n    }\n  )\n  return s\n}\n\nObject.setPrototypeOf(Stream.prototype, Function.prototype)\n\nfunction identical (a, b) {\n  return a === b\n}\n"],"names":["const","updates","sym","Symbol","x","kValue","kParents","kChildren","kFunction","NOOP","Stream","v","s","createStream","end","add","value","stream","arguments","length","setStreamValue","Object","defineProperties","configurable","writable","Set","setPrototypeOf","prototype","topUpdate","root","result","seen","visit","has","forEach","push","changed","reverse","getDescendants","Array","from","child","endStream","update","find","u","let","shift","recalculateStream","undefined","args","ret","parent","delete","identical","a","b","combine","fn","streams","opts","derived","initial","slice","skip","subscribe","this","map","clone","merge","scan","accum","dedupe","cmp","prev","source","target","val","when","resolver","isResolved","freshPromise","Promise","resolve","initialPromise","prom","unsub","throttle","period","timeout","callDue","startTimer","setTimeout","debounce","clearTimeout","pop","self","fromPromise","p","then","reason","Error","err","promise","Function"],"mappings":"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"}
{"version":3,"file":"index.mjs","sources":["../src/index.js"],"sourcesContent":["'use strict'\n\nfunction NOOP () {}\n\nconst STREAM_METHODS = 'map,scan,dedupe,dedupeWith,when,throttle,debounce'.split(\n  ','\n)\nconst METHODS = ['changed']\n\nclass Stream {\n  static create (...args) {\n    return new Stream(...args)\n  }\n\n  constructor (v) {\n    // current value of the stream\n    this.value = v\n    // notify callbacks to run on change\n    this.notify = new Set()\n    // fn which detaches this stream from its parents\n    this.detacher = NOOP\n\n    // function version of the stream. Call with no args\n    // to get current value. Or with args to set.\n    this.fn = this.update.bind(this)\n    // to map back from the function to the object\n    this.fn.stream = this\n\n    // make function versions of the methods\n    STREAM_METHODS.forEach(meth => {\n      this.fn[meth] = (...args) => this[meth](...args).fn\n    })\n    METHODS.forEach(meth => {\n      this.fn[meth] = (...args) => this[meth](...args)\n    })\n  }\n\n  subscribe (fn) {\n    this.notify.add(fn)\n    return () => this.notify.delete(fn)\n  }\n\n  endStream () {\n    this.notify.clear()\n    this.detacher()\n    this.detacher = NOOP\n  }\n\n  addEnd () {\n    // and end stream is a stream which, if updated, ends the stream\n    // (along with itself)\n    this.end = Stream.create()\n    this.end.subscribe(() => {\n      this.end.endStream()\n      this.endStream()\n    })\n    // the fn version of the stream also has an end, which is the fn version\n    // of `stream.end`\n    this.fn.end = this.end.fn\n  }\n\n  update (v) {\n    if (arguments.length !== 0) {\n      this.value = v\n      // work off a copy as some notifieds might change this\n      // as we are iterating (e.g. ends)\n      const notifies = Array.from(this.notify)\n      notifies.forEach(f => f(v))\n    }\n    return this.value\n  }\n\n  // creates a new Stream which is derived from applying a function\n  // to a list of (upstream) Streams\n  //\n  // The function has signature\n  // (stream,...,stream, self, Stream[] changed) => value\n  // where `changed` is the list of Stream objects that have changed.\n  //\n  static combine (fn, streams, initial) {\n    const derived = Stream.create(initial)\n    // any time any of the parent streams change, we re-run the\n    // function.\n    //\n    // The unsubscribes are stored and used as as the detacher for this\n    derived.detacher = callAll(\n      streams.map(stream =>\n        stream.subscribe(() => {\n          const ret = fn(...[...streams, derived, [stream]])\n          if (ret != null) derived.update(ret)\n        })\n      )\n    )\n\n    // Any time the `end`s of any of the parents are called, then we\n    // call our own `end`. The unsubs again form the detacher for the `end`\n    derived.addEnd()\n    derived.end.detacher = callAll(\n      streams.map(stream => stream.end.subscribe(x => derived.end.update(x)))\n    )\n    return derived\n  }\n\n  map (fn, initial) {\n    return Stream.combine(s => fn(s.value), [this], initial)\n  }\n\n  dedupeWith (cmp) {\n    let prev = this.value\n    return Stream.combine((source, target) => {\n      const val = source.value\n      if (!cmp(prev, val)) target.update(val)\n      prev = val\n    }, [this], this.value)\n  }\n\n  dedupe () {\n    return this.dedupeWith(identical)\n  }\n\n  static merge (...streams) {\n    const merged = Stream.combine((...args) => {\n      const changed = args.pop()\n      const self = args.pop()\n      changed.forEach(s => self.update(s.value))\n    }, streams)\n    return merged\n  }\n\n  scan (fn, accum) {\n    const derived = this.map(value => {\n      accum = fn(accum, value)\n      return accum\n    }, accum)\n    return derived\n  }\n\n  when (fn) {\n    // return a stream of promises which resolve when the condition\n    // is true\n    let resolver\n    let isResolved\n    const freshPromise = () =>\n      new Promise(resolve => {\n        resolver = resolve\n      })\n\n    const initialPromise = freshPromise()\n    if (fn(this.value)) {\n      isResolved = true\n      resolver()\n    }\n\n    return this.scan((prom, value) => {\n      if (fn(value)) {\n        if (!isResolved) {\n          isResolved = true\n          resolver()\n        }\n      } else {\n        if (isResolved) {\n          isResolved = false\n          prom = freshPromise()\n        }\n      }\n      return prom\n    }, initialPromise)\n  }\n\n  changed () {\n    // returns a promise which resolves when this stream next updates\n    return new Promise(resolve => {\n      const monitor = this.map(x => {\n        resolve(x)\n        monitor.end.update(true)\n      })\n    })\n  }\n\n  throttle (period) {\n    // returns a stream which updates at most every `period` ms\n    let timeout\n    let callDue\n    const update = () => {\n      // update this stream, and reset the callDue flag\n      ret.update(this.value)\n      callDue = false\n    }\n    const startTimer = () =>\n      setTimeout(() => {\n        // if we have called whilst the timer has been running, then\n        // do the throttled update, and set another timer going\n        if (callDue) {\n          update()\n          timeout = startTimer()\n        } else {\n          // no call has happened during the timer, so stop for now\n          timeout = null\n        }\n      }, period)\n    const ret = Stream.combine(() => {\n      // if we already have a timer going, then flag it needs to perform an update\n      if (timeout) {\n        callDue = true\n      } else {\n        // we do the `leading` edge call here, and then set a timer\n        update()\n        timeout = startTimer()\n      }\n    }, [this])\n    return ret\n  }\n\n  debounce (period) {\n    // create a stream which updates after a quiet period of `period` ms\n    let timeout\n    const update = () => {\n      ret.update(this.value)\n      timeout = null\n    }\n    const startTimer = () => {\n      if (timeout) clearTimeout(timeout)\n      timeout = setTimeout(update, period)\n    }\n    const ret = Stream.combine(startTimer, [this])\n    return ret\n  }\n}\n\nfunction callAll (cbs) {\n  return () => cbs.forEach(f => f())\n}\n\nfunction stream (...args) {\n  const str = Stream.create(...args)\n  str.addEnd()\n  return str.fn\n}\n\nfunction combine (fn, streamFuncs, initial) {\n  return Stream.combine(\n    (...args) => {\n      const changed = args.pop()\n      const self = args.pop()\n      return fn(...[...args.map(s => s.fn), self.fn, changed.map(s => s.fn)])\n    },\n    streamFuncs.map(sf => sf.stream),\n    initial\n  ).fn\n}\n\nfunction merge (...streamFuncs) {\n  return Stream.merge(...streamFuncs.map(sf => sf.stream)).fn\n}\n\nfunction identical (a, b) {\n  return a === b\n}\n\nObject.assign(stream, { combine, merge })\nexport default stream\n"],"names":["NOOP","const","STREAM_METHODS","split","METHODS","Stream","constructor","v","value","notify","Set","detacher","fn","this","update","bind","stream","forEach","meth","ref","args","callAll","cbs","f","str","create","addEnd","identical","a","b","subscribe","add","delete","endStream","clear","end","arguments","length","Array","from","combine","streams","initial","derived","map","ret","x","s","dedupeWith","cmp","prev","source","target","val","dedupe","merge","changed","pop","self","scan","accum","when","resolver","isResolved","freshPromise","Promise","resolve","initialPromise","prom","monitor","throttle","period","timeout","callDue","startTimer","setTimeout","debounce","clearTimeout","Object","assign","streamFuncs","sf"],"mappings":"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"}
{"version":3,"file":"index.mjs","sources":["../src/index.js"],"sourcesContent":["'use strict'\n\nconst sym =\n  typeof Symbol === 'function'\n    ? Symbol\n    : /* istanbul ignore next */ x => '$teme$_' + x\n\nconst kValue = sym('value')\nconst kParents = sym('parents')\nconst kChildren = sym('children')\nconst kFunction = sym('function')\n\n// The main entry point for source streams (as opposed to derived ones)\n//\n// A stream is a function (acting as a get/setter), but inheriting\n// prototypically from Stream\n//\nexport default function Stream (v) {\n  const s = createStream(v)\n  s.end = createStream(false)\n  // special link between stream and its `.end`\n  s.end[kChildren].add(s)\n  return s\n}\n\n// Constructs a stream function, setting its own proerties and prototype\nfunction createStream (value) {\n  function stream () {\n    if (arguments.length !== 0) {\n      setStreamValue(stream, arguments[0])\n    }\n    return stream[kValue]\n  }\n\n  Object.defineProperties(stream, {\n    [kValue]: { value, configurable: true, writable: true },\n    [kChildren]: { value: new Set(), configurable: true, writable: true },\n    [kParents]: { value: [], configurable: true, writable: true },\n    [kFunction]: { value: undefined, configurable: true, writable: true }\n  })\n  Object.setPrototypeOf(stream, Stream.prototype)\n  return stream\n}\n\nlet updates\n\nfunction setStreamValue (stream, value) {\n  const topUpdate = updates == null\n  if (topUpdate) updates = getDescendants(stream)\n\n  stream[kValue] = value\n  Array.from(stream[kChildren]).forEach(child => {\n    if (child.end === stream) return endStream(child)\n    const update = updates.find(u => u.stream === child)\n    if (!update) return updates.push({ stream: child, changed: [stream] })\n    update.changed.push(stream)\n  })\n\n  if (topUpdate) {\n    for (let update = updates.shift(); update; update = updates.shift()) {\n      if (update.changed.length !== 0) {\n        recalculateStream(update.stream, update.changed)\n      }\n    }\n    updates = undefined\n  }\n}\n\n// getDescendants\n//\n// perofrms a topological search to find all descendants of the given stream,\n// returning them in order than they should be updated - from most senior\n// (parent-like) to most junior (child-like)\nfunction getDescendants (root) {\n  const result = []\n  const seen = new Set()\n  // visit actuall creates the array from junior to senior order, processing\n  // the children before adding the current node. Finally we have to reverse\n  // this array to make it senior-to-junior\n  function visit (stream) {\n    if (seen.has(stream)) return\n    seen.add(stream)\n    stream[kChildren].forEach(visit)\n    result.push({ stream, changed: [] })\n  }\n  visit(root)\n  return result.reverse()\n}\n\nfunction recalculateStream (stream, changed) {\n  const args = [...stream[kParents], stream, changed]\n  const ret = stream[kFunction](...args)\n  if (ret != null) setStreamValue(stream, ret)\n}\n\nfunction endStream (stream) {\n  // disconnect from parents\n  stream[kParents].forEach(parent => parent[kChildren].delete(stream))\n  stream[kParents] = []\n  stream.end[kParents] = []\n\n  // set .end to true\n  stream.end[kValue] = true\n\n  // end all downstream from me too\n  Array.from(stream[kChildren]).forEach(endStream)\n}\n\n// The workhorse for all derived streams\n//\nStream.combine = function combine (fn, streams, opts = {}) {\n  const derived = Stream(opts.initial)\n  derived[kFunction] = fn\n  derived[kParents] = streams.slice()\n  streams.forEach(parent => parent[kChildren].add(derived))\n  if (!opts.skip) recalculateStream(derived, streams)\n  return derived\n}\n\n// common methods for all streams\nStream.prototype = {\n  subscribe (fn) {\n    const derived = this.map(fn, { skip: true })\n    return () => derived.end(true)\n  },\n\n  map (fn, opts) {\n    return Stream.combine(s => fn(s()), [this], opts)\n  },\n\n  clone () {\n    return this.map(x => x)\n  },\n\n  merge (...streams) {\n    return Stream.merge(...[this, ...streams])\n  },\n\n  scan (fn, accum) {\n    return this.map(\n      value => {\n        accum = fn(accum, value)\n        return accum\n      },\n      { skip: true, initial: accum }\n    )\n  },\n\n  dedupe (cmp, opts) {\n    if (cmp && typeof cmp === 'object') {\n      opts = cmp\n      cmp = undefined\n    }\n    cmp = cmp || identical\n    opts = opts || {}\n    let prev\n    if (!opts.skip) prev = this()\n    return Stream.combine(\n      (source, target) => {\n        const val = source()\n        if (!cmp(prev, val)) target(val)\n        prev = val\n      },\n      [this],\n      { skip: true, initial: prev }\n    )\n  },\n\n  when (fn) {\n    let resolver\n    let isResolved\n    const freshPromise = () =>\n      new Promise(resolve => {\n        resolver = resolve\n      })\n    const initialPromise = freshPromise()\n    if (fn(this())) {\n      isResolved = true\n      resolver()\n    }\n\n    return this.scan((prom, value) => {\n      if (fn(value)) {\n        if (!isResolved) {\n          isResolved = true\n          resolver()\n        }\n      } else {\n        if (isResolved) {\n          isResolved = false\n          prom = freshPromise()\n        }\n      }\n      return prom\n    }, initialPromise)\n  },\n\n  changed () {\n    return new Promise(resolve => {\n      const unsub = this.subscribe(x => {\n        resolve(x)\n        unsub()\n      })\n    })\n  },\n\n  throttle (period) {\n    let timeout\n    let callDue\n    const update = () => {\n      derived(this())\n      callDue = false\n    }\n    const startTimer = () =>\n      setTimeout(() => {\n        if (callDue) {\n          update()\n          timeout = startTimer()\n        } else {\n          timeout = null\n        }\n      }, period)\n    const derived = Stream.combine(\n      () => {\n        if (timeout) {\n          callDue = true\n        } else {\n          update() // leading edge\n          timeout = startTimer()\n        }\n      },\n      [this],\n      { skip: true }\n    )\n    return derived\n  },\n\n  debounce (period) {\n    let timeout\n    const update = () => {\n      derived(this())\n      timeout = null\n    }\n    const startTimer = () => {\n      if (timeout) clearTimeout(timeout)\n      timeout = setTimeout(update, period)\n    }\n    const derived = Stream.combine(startTimer, [this], { skip: true })\n    return derived\n  }\n}\n\nStream.merge = function merge (...streams) {\n  return Stream.combine(\n    (...args) => {\n      const changed = args.pop()\n      const self = args.pop()\n      changed.forEach(s => self(s()))\n    },\n    streams,\n    { skip: true }\n  )\n}\n\nStream.fromPromise = function fromPromise (p) {\n  const s = Stream()\n  p.then(\n    result => {\n      s(result)\n      s.end(true)\n    },\n    reason => {\n      if (!(reason instanceof Error)) {\n        const err = new Error('Rejected promise')\n        err.promise = p\n        err.reason = reason\n        reason = err\n      }\n      s(reason)\n      s.end(true)\n    }\n  )\n  return s\n}\n\nObject.setPrototypeOf(Stream.prototype, Function.prototype)\n\nfunction identical (a, b) {\n  return a === b\n}\n"],"names":["const","updates","sym","Symbol","x","kValue","kParents","kChildren","kFunction","Stream","v","s","createStream","end","add","value","stream","arguments","length","setStreamValue","Object","defineProperties","configurable","writable","Set","undefined","setPrototypeOf","prototype","topUpdate","root","result","seen","visit","has","forEach","push","changed","reverse","getDescendants","Array","from","child","endStream","update","find","u","let","shift","recalculateStream","args","ret","parent","delete","identical","a","b","combine","fn","streams","opts","derived","initial","slice","skip","subscribe","this","map","clone","merge","scan","accum","dedupe","cmp","prev","source","target","val","when","resolver","isResolved","freshPromise","Promise","resolve","initialPromise","prom","unsub","throttle","period","timeout","callDue","startTimer","setTimeout","debounce","clearTimeout","pop","self","fromPromise","p","then","reason","Error","err","promise","Function"],"mappings":"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"}
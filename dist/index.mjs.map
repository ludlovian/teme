{"version":3,"file":"index.mjs","sources":["../src/index.js"],"sourcesContent":["'use strict'\n\nfunction NOOP () {}\n\nconst STREAM_METHODS = 'map,scan,dedupe,dedupeWith,when,throttle,debounce'.split(\n  ','\n)\nconst METHODS = ['changed']\n\nclass Stream {\n  static create (...args) {\n    return new Stream(...args)\n  }\n\n  constructor (v) {\n    // current value of the stream\n    this.value = v\n    // notify callbacks to run on change\n    this.notify = new Set()\n    // fn which detaches this stream from its parents\n    this.detacher = NOOP\n\n    // function version of the stream. Call with no args\n    // to get current value. Or with args to set.\n    this.fn = this.update.bind(this)\n    // to map back from the function to the object\n    this.fn.stream = this\n\n    // make function versions of the methods\n    STREAM_METHODS.forEach(meth => {\n      this.fn[meth] = (...args) => this[meth](...args).fn\n    })\n    METHODS.forEach(meth => {\n      this.fn[meth] = (...args) => this[meth](...args)\n    })\n  }\n\n  subscribe (fn) {\n    this.notify.add(fn)\n    return () => this.notify.delete(fn)\n  }\n\n  endStream () {\n    this.notify.clear()\n    this.detacher()\n    this.detacher = NOOP\n  }\n\n  addEnd () {\n    // and end stream is a stream which, if updated, ends the stream\n    // (along with itself)\n    this.end = Stream.create()\n    this.end.subscribe(() => {\n      this.end.endStream()\n      this.endStream()\n    })\n    // the fn version of the stream also has an end, which is the fn version\n    // of `stream.end`\n    this.fn.end = this.end.fn\n  }\n\n  update (v) {\n    if (arguments.length !== 0) {\n      this.value = v\n      // work off a copy as some notifieds might change this\n      // as we are iterating (e.g. ends)\n      const notifies = Array.from(this.notify)\n      notifies.forEach(f => f(v))\n    }\n    return this.value\n  }\n\n  // creates a new Stream which is derived from applying a function\n  // to a list of (upstream) Streams\n  //\n  // The function has signature\n  // (stream,...,stream, self, Stream[] changed) => value\n  // where `changed` is the list of Stream objects that have changed.\n  //\n  // options:\n  //  - skip - do not run the function initially\n  //  - initial - initial value (if .skip set)\n  //\n  static combine (fn, streams, opts = {}) {\n    const derived = Stream.create()\n    function recalcDerived (changed) {\n      const ret = fn(...[...streams, derived, changed])\n      if (ret != null) derived.update(ret)\n    }\n\n    if (opts.skip) {\n      derived.value = opts.initial\n    } else {\n      recalcDerived(streams)\n    }\n\n    // any time any of the parent streams change, we re-run the\n    // function.\n    //\n    // The unsubscribes are stored and used as as the detacher for this\n    derived.detacher = callAll(\n      streams.map(stream => stream.subscribe(() => recalcDerived([stream])))\n    )\n\n    // Any time the `end`s of any of the parents are called, then we\n    // call our own `end`. The unsubs again form the detacher for the `end`\n    derived.addEnd()\n    derived.end.detacher = callAll(\n      streams.map(stream => stream.end.subscribe(x => derived.end.update(x)))\n    )\n    return derived\n  }\n\n  map (fn, opts) {\n    return Stream.combine(s => fn(s.value), [this], opts)\n  }\n\n  dedupe (cmp, opts) {\n    if (cmp && typeof cmp === 'object') {\n      opts = cmp\n      cmp = undefined\n    }\n    cmp = cmp || identical\n    opts = opts || {}\n    let prev\n    if (!opts.skip) prev = this.value\n    return Stream.combine(\n      (source, target) => {\n        const val = source.value\n        if (!cmp(prev, val)) target.update(val)\n        prev = val\n      },\n      [this],\n      { skip: true, initial: prev }\n    )\n  }\n\n  static merge (...streams) {\n    const merged = Stream.combine(\n      (...args) => {\n        const changed = args.pop()\n        const self = args.pop()\n        changed.forEach(s => self.update(s.value))\n      },\n      streams,\n      { skip: true }\n    )\n    return merged\n  }\n\n  scan (fn, accum) {\n    const derived = this.map(\n      value => {\n        accum = fn(accum, value)\n        return accum\n      },\n      { skip: true, initial: accum }\n    )\n    return derived\n  }\n\n  when (fn) {\n    // return a stream of promises which resolve when the condition\n    // is true\n    let resolver\n    let isResolved\n    const freshPromise = () =>\n      new Promise(resolve => {\n        resolver = resolve\n      })\n\n    const initialPromise = freshPromise()\n    if (fn(this.value)) {\n      isResolved = true\n      resolver()\n    }\n\n    return this.scan((prom, value) => {\n      if (fn(value)) {\n        if (!isResolved) {\n          isResolved = true\n          resolver()\n        }\n      } else {\n        if (isResolved) {\n          isResolved = false\n          prom = freshPromise()\n        }\n      }\n      return prom\n    }, initialPromise)\n  }\n\n  changed () {\n    // returns a promise which resolves when this stream next updates\n    return new Promise(resolve => {\n      const monitor = this.map(\n        x => {\n          resolve(x)\n          monitor.end.update(true)\n        },\n        { skip: true }\n      )\n    })\n  }\n\n  throttle (period) {\n    // returns a stream which updates at most every `period` ms\n    let timeout\n    let callDue\n    const update = () => {\n      // update this stream, and reset the callDue flag\n      ret.update(this.value)\n      callDue = false\n    }\n    const startTimer = () =>\n      setTimeout(() => {\n        // if we have called whilst the timer has been running, then\n        // do the throttled update, and set another timer going\n        if (callDue) {\n          update()\n          timeout = startTimer()\n        } else {\n          // no call has happened during the timer, so stop for now\n          timeout = null\n        }\n      }, period)\n    const ret = Stream.combine(\n      () => {\n        // if we already have a timer going, then flag it needs to perform an update\n        if (timeout) {\n          callDue = true\n        } else {\n          // we do the `leading` edge call here, and then set a timer\n          update()\n          timeout = startTimer()\n        }\n      },\n      [this],\n      { skip: true }\n    )\n    return ret\n  }\n\n  debounce (period) {\n    // create a stream which updates after a quiet period of `period` ms\n    let timeout\n    const update = () => {\n      ret.update(this.value)\n      timeout = null\n    }\n    const startTimer = () => {\n      if (timeout) clearTimeout(timeout)\n      timeout = setTimeout(update, period)\n    }\n    const ret = Stream.combine(startTimer, [this], { skip: true })\n    return ret\n  }\n}\n\nfunction callAll (cbs) {\n  return () => cbs.forEach(f => f())\n}\n\nfunction stream (...args) {\n  const str = Stream.create(...args)\n  str.addEnd()\n  return str.fn\n}\n\nfunction combine (fn, streamFuncs, initial) {\n  return Stream.combine(\n    (...args) => {\n      const changed = args.pop()\n      const self = args.pop()\n      return fn(...[...args.map(s => s.fn), self.fn, changed.map(s => s.fn)])\n    },\n    streamFuncs.map(sf => sf.stream),\n    initial\n  ).fn\n}\n\nfunction merge (...streamFuncs) {\n  return Stream.merge(...streamFuncs.map(sf => sf.stream)).fn\n}\n\nfunction identical (a, b) {\n  return a === b\n}\n\nObject.assign(stream, { combine, merge })\nexport default stream\n"],"names":["NOOP","const","STREAM_METHODS","split","METHODS","Stream","constructor","v","value","notify","Set","detacher","fn","this","update","bind","stream","forEach","meth","ref","args","callAll","cbs","f","str","create","addEnd","identical","a","b","subscribe","add","delete","endStream","clear","end","arguments","length","Array","from","combine","streams","opts","derived","recalcDerived","changed","ret","skip","initial","map","x","s","dedupe","cmp","prev","undefined","source","target","val","merge","pop","self","scan","accum","when","resolver","isResolved","freshPromise","Promise","resolve","initialPromise","prom","monitor","throttle","period","timeout","callDue","startTimer","setTimeout","debounce","clearTimeout","Object","assign","streamFuncs","sf"],"mappings":"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"}
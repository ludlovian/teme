{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["'use strict'\n\nconst sym =\n  typeof Symbol === 'function'\n    ? Symbol\n    : /* istanbul ignore next */ x => '$teme$_' + x\n\nconst kValue = sym('value')\nconst kNotify = sym('notify')\nconst kDetacher = sym('detacher')\n\n// The main entry point for source streams (as opposed to derived ones)\n//\n// A stream is a function (acting as a get/setter), but inheriting\n// prototypically from Stream\n//\nexport default function Stream (v) {\n  const s = createStream(v)\n  addEndStream(s)\n  return s\n}\n\n// Constructs a stream function, setting its own proerties and prototype\nfunction createStream (value) {\n  function stream () {\n    if (arguments.length !== 0) {\n      const value = arguments[0]\n      stream[kValue] = value\n      // the list of notifies is created as a separate array, as some\n      // of the notify callbacks will update/delete the notify list as\n      // we are traversing it\n      const notifies = Array.from(stream[kNotify])\n      notifies.forEach(f => f(value))\n    }\n    return stream[kValue]\n  }\n\n  Object.defineProperties(stream, {\n    [kValue]: { value, configurable: true, writable: true },\n    [kNotify]: { value: new Set(), configurable: true, writable: true },\n    [kDetacher]: { value: new Set(), configurable: true, writable: true }\n  })\n  Object.setPrototypeOf(stream, Stream.prototype)\n  return stream\n}\n\n// adds a '.end' stream to a stream, setting up the notifies\nfunction addEndStream (s) {\n  s.end = createStream()\n  s.end.subscribe(() => {\n    endStream(s.end)\n    endStream(s)\n  })\n}\n\nfunction endStream (s) {\n  s[kNotify].clear()\n  Array.from(s[kDetacher]).forEach(f => f())\n  s[kDetacher].clear()\n}\n\n// The workhorse for all derived streams\n//\nStream.combine = function combine (fn, streams, opts = {}) {\n  const derived = createStream()\n  addEndStream(derived)\n\n  function recalcDerived (changed) {\n    const ret = fn(...[...streams, derived, changed])\n    if (ret != null) derived(ret)\n  }\n\n  if (opts.skip) {\n    derived(opts.initial)\n  } else {\n    recalcDerived(streams)\n  }\n\n  streams.forEach(stream => {\n    // if the upstream updates, then we re-derive\n    derived[kDetacher].add(stream.subscribe(() => recalcDerived([stream])))\n    // if the upstream ends, then so do we\n    derived.end[kDetacher].add(stream.end.subscribe(x => derived.end(x)))\n  })\n  return derived\n}\n\n// common methods for all streams\nStream.prototype = {\n  subscribe (fn) {\n    this[kNotify].add(fn)\n    return () => this[kNotify].delete(fn)\n  },\n\n  map (fn, opts) {\n    return Stream.combine(s => fn(s()), [this], opts)\n  },\n\n  clone () {\n    return this.map(x => x)\n  },\n\n  merge (...streams) {\n    return Stream.merge(...[this, ...streams])\n  },\n\n  scan (fn, accum) {\n    return this.map(\n      value => {\n        accum = fn(accum, value)\n        return accum\n      },\n      { skip: true, initial: accum }\n    )\n  },\n\n  dedupe (cmp, opts) {\n    if (cmp && typeof cmp === 'object') {\n      opts = cmp\n      cmp = undefined\n    }\n    cmp = cmp || identical\n    opts = opts || {}\n    let prev\n    if (!opts.skip) prev = this()\n    return Stream.combine(\n      (source, target) => {\n        const val = source()\n        if (!cmp(prev, val)) target(val)\n        prev = val\n      },\n      [this],\n      { skip: true, initial: prev }\n    )\n  },\n\n  when (fn) {\n    let resolver\n    let isResolved\n    const freshPromise = () =>\n      new Promise(resolve => {\n        resolver = resolve\n      })\n    const initialPromise = freshPromise()\n    if (fn(this())) {\n      isResolved = true\n      resolver()\n    }\n\n    return this.scan((prom, value) => {\n      if (fn(value)) {\n        if (!isResolved) {\n          isResolved = true\n          resolver()\n        }\n      } else {\n        if (isResolved) {\n          isResolved = false\n          prom = freshPromise()\n        }\n      }\n      return prom\n    }, initialPromise)\n  },\n\n  changed () {\n    return new Promise(resolve => {\n      const unsub = this.subscribe(x => {\n        resolve(x)\n        unsub()\n      })\n    })\n  },\n\n  throttle (period) {\n    let timeout\n    let callDue\n    const update = () => {\n      derived(this())\n      callDue = false\n    }\n    const startTimer = () =>\n      setTimeout(() => {\n        if (callDue) {\n          update()\n          timeout = startTimer()\n        } else {\n          timeout = null\n        }\n      }, period)\n    const derived = Stream.combine(\n      () => {\n        if (timeout) {\n          callDue = true\n        } else {\n          update() // leading edge\n          timeout = startTimer()\n        }\n      },\n      [this],\n      { skip: true }\n    )\n    return derived\n  },\n\n  debounce (period) {\n    let timeout\n    const update = () => {\n      derived(this())\n      timeout = null\n    }\n    const startTimer = () => {\n      if (timeout) clearTimeout(timeout)\n      timeout = setTimeout(update, period)\n    }\n    const derived = Stream.combine(startTimer, [this], { skip: true })\n    return derived\n  }\n}\n\nStream.merge = function merge (...streams) {\n  return Stream.combine(\n    (...args) => {\n      const changed = args.pop()\n      const self = args.pop()\n      changed.forEach(s => self(s()))\n    },\n    streams,\n    { skip: true }\n  )\n}\n\nStream.fromPromise = function fromPromise (p) {\n  const s = Stream()\n  p.then(\n    result => {\n      s(result)\n      s.end(true)\n    },\n    reason => {\n      if (!(reason instanceof Error)) {\n        const err = new Error('Rejected promise')\n        err.promise = p\n        err.reason = reason\n        reason = err\n      }\n      s(reason)\n      s.end(true)\n    }\n  )\n  return s\n}\n\nObject.setPrototypeOf(Stream.prototype, Function.prototype)\n\nfunction identical (a, b) {\n  return a === b\n}\n"],"names":["const","sym","Symbol","x","kValue","kNotify","kDetacher","Stream","v","s","createStream","addEndStream","value","stream","arguments","length","Array","from","forEach","f","Object","defineProperties","configurable","writable","Set","setPrototypeOf","prototype","end","subscribe","endStream","clear","identical","a","b","combine","fn","streams","opts","derived","recalcDerived","changed","ret","skip","initial","add","this","delete","map","clone","merge","scan","accum","dedupe","cmp","prev","undefined","source","target","val","when","resolver","isResolved","freshPromise","Promise","resolve","initialPromise","prom","unsub","throttle","period","timeout","callDue","update","startTimer","setTimeout","debounce","clearTimeout","args","pop","self","fromPromise","p","then","result","reason","Error","err","promise","Function"],"mappings":"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"}